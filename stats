#!/bin/sh
set -euf

##
# Statistics calculations for numbers.
#
# Examples:
#
#     $ echo "1 2 4" | stats --count
#     3
#
#     $ echo "1 2 4" | stats --min
#     1
#
#     $ echo "1 2 4" | stats --max
#     4
#
#     $ echo "1 2 4" | stats --range
#     3
#
#     $ echo "1 2 4" | stats --sum
#     7
#
#     $ echo "1 2 4" | stats --median
#     2
#
#     $ echo "1 2 4" | stats --mean
#     2.33333
#
#     $ echo "1 2 4" | stats --sum-of-squares
#     4.66667
#
#     $ echo "1 2 4" | stats --standard-deviation
#     1.24722
#
#     $ echo "1 2 4" | stats --coefficient-of-variance
#     0.534523
#
# Example of output using a label on each item:
#
#     $ echo "1 2 4" | stats --output-label --min --max --range
#     min 1 max 4 range 3
#
# Example of output using comma separated values:
#
#     $ echo "1 2 4" | stats --output-csv --min --max --range
#     1,4,3
#
# Example of output using tab separated values:
#
#     $ echo "1 2 4" | stats --output-tsv --min --max --range
#     1\t4\t3
#
# Options for stats functions:
#
#     --n, --count, --length, --size    The number of items.
#     --min, --minimum                  The minimum value.
#     --max, --maximum                  The maximum value.
#     --range, --spread                 The range, which is maximum - minimum.
#     --sum, --total                    The sum.
#     --mean, --average                 The mean a.k.a. average.
#     --median                          The median.
#     --mode                            The mode. [#TODO]
#     --ss, --sum-of-squares            The sum of squares (SS).
#     --sd, --standard-deviation        The standard deviation (SD).
#     --cv, --coefficient-of-variance   The coefficient of variance (CV).
#
# Options for input:
#
#     --input-fields    The input uses fields, one number per field. This produces one output per record.
#     --input-records   The input uses records, one number per record. This produces one output overall.
#     --input-sorted    Tell the script that the input is already sorted ascending. This optimizes `median`.
#
# Options for output:
#
#     --output-label     Label each output item, such as "sum 123". Default is unlabeled, such as "123".
#     --output-csv       Output comma-separated values. [#TODO Default is awk field separator]
#     --output-tsv       Output tab-separated values. [#TODO Default is awk field separator]
#
# ## Implementation
#
# Each statistics function takes an array of numbers and an array of metadata.
# The metadata includes memoization a.k.a. cache of results, sort status, etc.
#
# Metadata examples:
#
#   * `meta["sorted"]` is boolean 0|1 if the list is sorted.
#   * `meta["sum"]` is the memo cache of the `sum` function result.
#
# ## Function conventions
#
# The `sum` function is a good example of a simple function
# that uses many of this script's function conventions.
#
#     function sum(a, meta,  x, i) {     # typical parameters
#       if (!("sum" in meta)) {          # check memo
#         x = 0                          # explict zero
#         for (i in a) {                 # iterate
#           x += a[i]                    # add
#         }
#         meta["sum"] = x                # set memo
#       }
#       return meta["sum"]               # return memo
#     }
#
#  The function declaration parameters `(a, meta,  x, i)` are quite common:
#
#    * `a` is the input array.
#    * `meta` is the input metadata array.
#    * `x` is a typically the variable that the function is calculating.
#    * `i` is a typical loop index, such as `for (i = 1, i < n; i++)`
#
# Conventions:
#
#   * Use the `awk` convention of two spaces to separate the function
#     declaration's list of input variables from internal variables.
#
#   * Internal variables use an underscore prefix.
#
#   * Check if the array has a key that is the same name as the function.
#     If the key exists, then it is a memoize cache result.
#
#   * Explicitly set all internal variables because this helps
#     catch bugs and prevent them, and tends to be easier to read.
#
#   * After the loop, we cache the result in the array by using metadata,
#     specifically a key that is the same name as the function.
#
#   * We return the cache value, rather than the temp loop variable,
#     because in our experience this helps prevent bugs.
#
# ## Tracking
#
# Author: Joel Parker Henderson (joel@joelparkerhenderson.com)
# License: GPL
# Created: 2015-03-28
# Updated: 2015-09-27
# Version: 2.0.0
##

awk '

## Statistics Functions

# Number of items, a.k.a. count, length, size.
function n(a, meta) {
  if (!("n" in meta)) {
    meta["n"] = len(a)
  }
  return meta["n"]
}

# Min, a.k.a. minimum.
function min(a, meta) {
  if (!("min" in meta)) {
    if (meta["sorter"]) sorter(a, meta)
    if (meta["sorted"]) {
      meta["min"] = first_via_meta(a, meta)
    } else {
      meta["min"] = min_via_scan(a)
    }
  }
  return meta["min"]
}

# Calculate the minimum via a full scan of the list.
# Use the optimization heuristic of starting with the first index:
# the more the array is already sorted, the fewer the updates.
function min_via_scan(a, meta, _min, i) {
  if (!("min_via_scan" in meta)) {
    _min = first_via_meta(a, meta)
    for (i in a) {
      if (a[i] < _min) {
        _min = a[i]
      }
    }
    meta["min_via_scan"] = _min
  }
  return meta["min_via_scan"]
}

# Max, a.k.a. maximum.
function max(a, meta) {
  if (!("max" in meta)) {
    if (meta["sorter"]) sorter(a, meta)
    if (meta["sorted"]) {
      meta["max"] = last_via_meta(a, meta)
    } else {
      meta["max"] = max_via_scan(a, meta)
    }
  }
  return meta["max"]
}

# Calculate the maximum via a full scan of the list.
# Use the optimization heuristic of starting with the last index:
# the more the array is already sorted, the fewer the updates.
function max_via_scan(a, meta,  _max, i) {
  if (!("max_via_scan" in meta)) {
    _max = last_via_meta(a, meta)
    for (i in a) {
      if (a[i] > _max) {
        _max = a[i]
      }
    }
    meta["max_via_scan"] = _max
  }
  return meta["max_via_scan"]
}

# Range, a.k.a. spread.
function range(a, meta) {
  if (!("range" in meta)) {
    meta["range"] = max(a, meta) - min(a, meta)
  }
  return meta["range"]
}

# Sum, a.k.a. total.
function sum(a, meta, _sum, i) {
  if (!("sum" in meta)) {
    _sum = 0
    for (i in a) {
      _sum += a[i]
    }
    meta["sum"] = _sum
  }
  return meta["sum"]
}

# Mean, a.k.a. arithmetic mean, a.k.a average.
function mean(a, meta) {
  if (!("mean" in meta)) {
    meta["mean"] = sum(a) / n(a)
  }
  return meta["mean"]
}

# Median
function median(a, meta,  _n) {
  if (!("median" in meta)) {
    sorter(a, meta)
    _n = n(a, meta)
    if (_n % 2) {
      meta["median"] = a[(_n + 1) / 2]
    } else {
      meta["median"] = a[(_n / 2)] + (a[(_n / 2) + 1] / 2.0)
    }
  }
  return meta["median"]
}

# Sum of Squares, a.k.a. SS.
function sum_of_squares(a, meta,  _sum, _mean, i) {
  if (!("sum_of_squares" in meta)) {
    _sum = 0
    _mean = mean(a)
    for (i in a) {
      _sum += (a[i] - _mean) ^ 2;
    }
    meta["sum_of_squares"] = _sum
  }
  return meta["sum_of_squares"]
}

# Standard Deviation, a.k.a. SD.
function standard_deviation(a, meta) {
  if (!("standard_deviation" in meta)) {
    meta["standard_deviation"] = sqrt(sum_of_squares(a, meta) / n(a, meta))
  }
  return meta["standard_deviation"]
}

# Coefficient of Variance, a.k.a. CV
function coefficient_of_variance(a, meta) {
  if (!("coefficient_of_variance" in meta)) {
    meta["coefficient_of_variance"] = standard_deviation(a, meta) / mean(a, meta)
  }
  return meta["coefficient_of_variance"]
}

## Array Functions

function dump(a) {
  print "+++"
  for (k in a) {
    print k, a[k]
  }
  print "---"
}

function len(a,  i, k) {
  for (i in a) k++
  return k
}

function first_via_length(a) {
  return a[1]
}

function first_via_meta(a, meta) {
  return a[1]
}

function last_via_length(a) {
  return a[length(a)]
}

function last_via_meta(a, meta) {
  return a[meta["n"]]
}

function push_via_length(a, item) {
  a[length(a)+1] = item
}

function push_via_meta(a, meta, item) {
  a[++meta["n"]] = item
}

function pushes_via_length(a, items, _n, i) {
  _n = length(a)
  for (_i in items) {
    a[++_n] = items[_i]
  }
}

function pushes_via_meta(a, meta, items, _n, i) {
  _n = meta["n"]
  for (_i in items) {
    a[++_n] = items[_i]
  }
  meta["n"] = _n
}

function pop_via_length(a, _x, _n, _i) {
  _n = length(a)
  if (_n) {
    _x = a[_n]
    delete a[_n]
    return x
  } else {
    return ""
  }
}

function pop_via_meta(a, meta, _x, _i) {
  _n = meta["n"]
  if (_n) {
    x = a[_n]
    delete a[_n]
    meta["n"]--
    return x
  } else {
    return ""
  }
}

## Helper Functions

function abs(value) {
  return (value < 0 ? -value : value)
}

function sorter(a, meta) {
  if (!("sorted" in meta)) {
    #TODO research if `asort` is POSIX or if there are alternatives.
    asort(a)
    meta["sorted"] = 1
  }
}

function reset() {
  split("", __a)
  split("", __meta)
  __meta["n"] = 0
}

## Word Functions

#TODO optimize, such as by creating a word lookup, or init functions, etc.
function word_to_setup(a, meta, word) {
  if (word == "input-fields")
    _calculate_via = "fields"
  else if (word == "input-records")
    _calculate_via == "records"
  else if (word == "input-sorted")
    meta["sorted"] = 1 #true
  else if (word == "output-label")
    _output_label = 1
  else if (word == "output-csv")
    _output_field_join = ","
  else if (word == "output-tsv")
    _output_field_join = "\t"
  else if (word == "median")
    meta["sorter"] = 1
  else
    return ""
}

#TODO optimize, such as by creating a word lookup.
function word_to_function(a, meta, word) {
  if (word == "n" || word == "count" || word == "length" || word == "size")
    return (n(a, meta))
  else if (word == "min" || word == "minimum")
    return min(a, meta)
  else if (word == "max" || word == "maximum")
    return max(a, meta)
  else if (word == "range" || word == "spread")
    return range(a, meta)
  else if (word == "sum" || word == "total")
    return sum(a, meta)
  else if (word == "median")
    return median(a, meta)
  else if (word == "mean" || word == "average")
    return mean(a, meta)
  else if (word == "ss" || word == "sum-of-squares")
    return sum_of_squares(a, meta)
  else if (word == "sd" || word == "standard-deviation")
    return standard_deviation(a, meta)
  else if (word == "cv" || word == "coefficient-of-variance")
    return coefficient_of_variance(a, meta)
  else
    return ""
}

function word_to_s(a, meta, word,  x,s) {
  s = ""
  x = word_to_function(a, meta, word)
  if (x) {
    if (_output_label) {
      s = _output_field_prefix word _output_field_midfix x _output_field_suffix
    } else {
      s = "" x
    }
  }
  return s
}

function words_to_s(a, meta, words,  i,s,s2) {
  s = ""
  for (i in words) {
    x = word_to_s(a, meta, words[i])
    s = s x _output_field_join
  }
  #TODO better way to trim
  sub(/^ +/,"",s)
  sub(/[^0-9]+$/,"",s)
  return s
}

## Argv Functions

function parse_argv(i, word) {
  for (i in ARGV) {
    #TODO optimize?
    if (ARGV[i] ~ /^--(input-fields|input-records|input-sorted|output-label|output-csv|output-tsv|n|count|length|size|min|minimum|max|maximum|range|spread|sum|total|median|mean|average|ss|sum-of-squares|sd|standard-deviation|cv|coefficient-of-variance)/) {
      word = ARGV[i]
      delete ARGV[i]
      sub(/^--/, "", word)
      push_via_length(__words, word)
      word_to_setup(__a, __meta, word)
    }
  }
}

function save_argv() {
  for (i in ARGV) {
    argv[i] = ARGV[i]
  }
}

## Output Functions

function output() {
  print words_to_s(__a, __meta, __words)
  return
  print \
  "n", n(a, meta),
  "min", min(a, meta),
  "max", max(a, meta),
  "range", range(a, meta),
  "sum", sum(a, meta),
  "median", median(a, meta),
  "mean", mean(a, meta),
  "ss", sum_of_squares(a, meta),
  "sd", standard_deviation(a, meta),
  "cv", coefficient_of_variance(a, meta)
}

## Main

function init() {
  reset()
  split("", __words)
  _output_field_prefix = ""
  _output_field_midfix = " "
  _output_field_suffix = ""
  _output_field_join = " "
  _calculate_via = "all" # enum "all", "fields", "records"
}

BEGIN{
  init()
  save_argv()
  parse_argv()
}

{
  if (_calculate_via == "all") {
    split($0, fields)
    pushes_via_meta(__a, __meta, fields)
  }
  else if (_calculate_via == "fields") {
    reset()
    split($0, fields)
    pushes_via_meta(__a, __meta, fields)
    output()
  }
  else if (_calculate_via == "records") {
    __a[NR] = $1
  }
}

END{
  if (_calculate_via == "all") {
    output()
  }
  else if (_calculate_via == "fields") {
    #noop
  }
  else if (_calculate_via == "records") {
    meta["n"] = NR
    output()
  }
}' "$@"
